\documentclass[11pt, letter]{article}
%\include{macro-file}

\def\mainroot{ell_1}

%%%%%% Margins and spacing
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{url}
\usepackage{caption}
\usepackage[compact]{titlesec}
%\usepackage{bm}
\usepackage{txfonts}
%\usepackage{times}
\usepackage{color}
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{cancel}
\usepackage{soul}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{algpseudocode}
\usepackage{listings}

\usepackage{sidecap}
\sidecaptionvpos{figure}{c}

\usepackage{enumitem}
\setlist{nolistsep}

\definecolor{commentcolor}{HTML}{FF3300}
\definecolor{keywordcolor}{HTML}{0000FF}
\definecolor{idcolor}{HTML}{000099}

%\setcounter{MaxMatrixCols}{20}

\newcommand\mjsnote[1]{{\bf [#1 -mjs]}}

\newcommand{\meas}{{\mathbf \mu}}
\newcommand{\tightpgh}[1]{\vskip 3pt\noindent\textbf{#1}}
\newcommand{\signalw}{{\mathbf w}}
\newcommand{\signalx}{{\mathbf x}}
\newcommand{\signaly}{{\mathbf y}}
\newcommand{\signalz}{{\mathbf z}}

%\expandafter\def\expandafter\normalsize\expandafter{%
%    \normalsize
%    \setlength\abovedisplayskip{2pt}
%    \setlength\belowdisplayskip{2pt}
%    \setlength\abovedisplayshortskip{0pt}
%    \setlength\belowdisplayshortskip{0pt}
%}\makeatother
%
%\renewcommand\floatpagefraction{.9}
%\renewcommand\topfraction{.9}
%\renewcommand\bottomfraction{.9}
%\renewcommand\textfraction{.1}
%\setlength{\textfloatsep}{10pt plus 1.0pt minus 2.0pt}

% Jian \DeclareMathOperator*{\median}{median}
\newcommand{\mb}{\ensuremath\mathbf}
\newcommand{\F}{\ensuremath\mathbb{F}}

\title{CSE 537 Assignment 1 Report: Peg Solitaire}
\author{
%\alignauthor
Remy Oukaour \\
	{\small SBU ID: 107122849}\\
	{\small \texttt{remy.oukaour@gmail.com}}
%\alignauthor
\and
Jian Yang \\
	{\small SBU ID: 110168771}\\
	{\small \texttt{jian.yang.1@stonybrook.edu}}
%\alignauthor
}
\date{Thursday, September 24, 2015}

\raggedbottom

\begin{document}

\maketitle

\begin{abstract}
This report describes our submission for assignment 1 in the CSE 537 course on
artificial intelligence. Assignment 1 requires us to implement three algorithms
for solving a game of Peg Solitaire: iterative-deepening depth-first search
(ID-DFS), and A* search with two different heuristics. In this report, we
discuss the implementation details and compare the performance of six solutions
(ID-DFS and five A* heuritsics, of which we settled on two).
\end{abstract}

\section{Introduction}

TODO: write the introduction

\section{Implementation}

We were given four Python code files implementing the assignment framework:
\(readGame.py\), \(pegSolitaireUtils.py\), \(search.py\), and \(pegSolitaire.py\).
We did not need to edit \(readGame.py\) or \(pegSolitaire.py\), but only had to
implement utility classes and methods in \(pegSolitaireUtils.py\) and the search
algorithms in \(search.py\).

\subsection{Data structures}

The original data structure given in \(pegSolitaireUtils.py\) was a single
class \(game\) containing the game state as a 2-dimensional 7\times7 array of
integers, a trace of the moves taken to reach that state, and an overall count
of the nodes expanded by the search algorithm. To make the implementation more
clear, we split this into two classes: \(game\), a singleton class storing
overall state for a search (the original game state, final move trace, and
expanded node count), and \(gameNode\), a class which a search algorithm can
repeatedly create as it explores the game tree.

The \(gameNode\) class contains some optimizations. We flattened the game state
into a 1-dimensional array of 49 integers to speed up indexing and simplify
copying. Thus, an index \(gameState[i][j]\) would become \(gameState[i*7+j]\).
We also cache two pieces of data when a \(gameNode\) is created: a count of
pegs remaining on the board, and a \(key\) state chosen from the eight symmetric
states under rotation and reflection. This data is used by our search algorithms
to prune search trees.

\subsection{Utility methods}

We were required to implement four utility methods in \(pegSolitaireUtils.py\):

\begin{enumerate}

\item \(is\_corner(self, pos)\):

\lstset{language=Python,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{keywordcolor}\ttfamily,
	identifierstyle=\color{idcolor}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{commentcolor}\ttfamily,
	numberstyle=\color{keywordcolor}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}[frame=single]
def is_corner(self, pos):
	"""
	Return whether a position is a corner/wall,
	i.e. not a hole or peg.
	"""
	return 0 <= pos < 49 and self.state[pos] != -1
\end{lstlisting}

In implementation, we actually used another function
\(\_\_getitem\_\_(self, pos)\) instead: \\
\lstset{language=Python,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{keywordcolor}\ttfamily,
	identifierstyle=\color{idcolor}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{commentcolor}\ttfamily,
	numberstyle=\color{keywordcolor}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}

\begin{lstlisting}[frame=single]
def __getitem__(self, pos):
	"""
	node[pos] is bounds-checked shorthand for node.state[pos].
	"""
	return self.state[pos] if 0 <= pos < 49 else -1
\end{lstlisting}

\item \(is\_validMove(self, oldPos, direction)\):

\lstset{language=Python,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{keywordcolor}\ttfamily,
	identifierstyle=\color{idcolor}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{commentcolor}\ttfamily,
	numberstyle=\color{keywordcolor}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}[frame=single]
def is_validMove(self, oldPos, direction):
	"""
	Return whether it is valid to move a peg from a given
	position in a given direction. The position must have a
	peg, the destination must be empty, and the intermediate
	position must have another peg.
	"""
	midPos = self.getNextPosition(oldPos, direction)
	newPos = self.getNextPosition(midPos, direction)
	# 1 is a peg, and 0 is a hole
	# Since oldPos is valid, don't use bounds-checked
	# indexing for it
	return (self.state[oldPos] == self[midPos] == 1
		and self[newPos] == 0)
\end{lstlisting}

\item \(getNextPosition(self, oldPos, direction)\):

\lstset{language=Python,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{keywordcolor}\ttfamily,
	identifierstyle=\color{idcolor}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{commentcolor}\ttfamily,
	numberstyle=\color{keywordcolor}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}[frame=single]
@staticmethod
def getNextPosition(oldPos, direction):
	"""
	Return the new position after moving in the given
	direction (-7 is north/up, 1 is east/right, 7 is south/down,
	and -1 is west/left). Invalid movements outside the bounds
	of the board will return positions such that
	is_corner(position) returns True.
	"""
	newPos = oldPos + direction
	# If direction is 7 or -7 (changing rows),
	# newPos is already correct
	return (newPos if direction == 7 or direction == -7 or
	# If direction is 1 or -1 (changing columns),
	# the row should not change
		newPos // 7 == oldPos // 7 else -1)
\end{lstlisting}

\item \(getNextState(self, oldPos, direction)\):

\lstset{language=Python,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{keywordcolor}\ttfamily,
	identifierstyle=\color{idcolor}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{commentcolor}\ttfamily,
	numberstyle=\color{keywordcolor}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}[frame=single]
def getNextState(self, oldPos, dir, pegSol):
	"""
	Return a child node of the current one, created by a
	given valid move. The given game has its count of
	expanded nodes incremented.
	"""
	pegSol.nodesExpanded += 1
	if not self.is_validMove(oldPos, direction):
		print "Error, You are not checking for valid move"
		exit(0)
	midPos = self.getNextPosition(oldPos, direction)
	newPos = self.getNextPosition(midPos, direction)
	# x[:] makes a copy of x (necessary to avoid mutating
	# self.state when updating childState)
	childState = self.state[:]
	childState[oldPos] = 0 # The peg moves from here
	childState[midPos] = 0 # The jumped-over peg is removed
	childState[newPos] = 1 # The peg moves to this hole
	# Convert positions back into pairs for printing
	childTrace = self.trace + [(oldPos // 7, oldPos \% 7),
		(newPos // 7, newPos \% 7)]
	return gameNode(childState, childTrace,
		self.pegCount - 1, self.heuristic)
\end{lstlisting}

\end{enumerate}

\subsection{Search functions}

We were required to implement our search functions and heuristics in
\(search.py\).

\subsubsection{ID-DFS}

We implemented ID-DFS straightforwardly, based on figure 3.17 (section 3.4,
page 88) and figure 3.18 (section 3.4, page 89) in the textbook. However, we
also maintain a set of explored nodes (modulo symmetry) to avoid revisiting,
which helps prune the search tree.

\subsubsection{A*}

We implemented A* based on figure 3.14 (section 3.4, page 84) in the textbook.
However, we take the set of \(explored\) nodes modulo symmetry to further prune
the search tree. (One game state can be solved if and only if its seven
symmetrical states can be solved, so when one has been expanded the other
seven can be pruned.)

\subsubsection{First A* heuristic}

\lstset{language=Python,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{keywordcolor}\ttfamily,
	identifierstyle=\color{idcolor}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{commentcolor}\ttfamily,
	numberstyle=\color{keywordcolor}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}[frame=single]
def heuristicOne(node):
	"""
	This heuristic counts the number of "dangling" pegs (those
	without any neighbors) and adds it to twice the number of
	pegs remaining on the board.

	We penalize dangling pegs because they cannot be removed
	without first moving another peg to a neighboring hole,
	which may not be possible.
	"""
	num_dangling = 0
	for i in xrange(49):
		if node.state[i] != 1: continue
		for direction in [7, 1, -7, -1]:
			if node[i + direction] == 1:
				break
		else:
			num_dangling += 1
	return node.pegCount * 2 + num_dangling
\end{lstlisting}

\subsubsection{Second A* heuristic}

\lstset{language=Python,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{keywordcolor}\ttfamily,
	identifierstyle=\color{idcolor}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{commentcolor}\ttfamily,
	numberstyle=\color{keywordcolor}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}

\begin{lstlisting}[frame=single]
def heuristicTwo(node, sum=sum, xrange=xrange):
	"""
	This heuristic sums the estimated difficulty of removing
	each peg and adds it to twice the number of pegs remaining
	on the board.

	We chose the difficulty values after some trial and error.
	The outer four areas of the board are generally less
	maneuverable than the center, and further from the eventual
	goal of the very central hole. This applies especially to
	the eight outer corners, which have fewer neighbors to jump
	over. The four inner corners are only slightly easier, since
	they have more neighbors but are still not in the ideal rows
	or columns. (Note that pegs in the outer and inner corners
	can only move within those positions, never to a non-corner
	hole.) The center peg is the end goal of the game, but prior
	to that having a peg sit there is not quite useful (since if
	you are left with two pegs and one is in the center, the
	game is unsolvable).
	"""
	difficulties = [
		0, 0, 4, 1, 4, 0, 0,
		0, 0, 1, 1, 1, 0, 0,
		4, 1, 2, 0, 2, 1, 4,
		1, 1, 0, 1, 0, 1, 1,
		4, 1, 2, 0, 2, 1, 4,
		0, 0, 1, 1, 1, 0, 0,
		0, 0, 4, 1, 4, 0, 0,
	]
	return node.pegCount * 2 + sum(difficulties[k]
		for k in xrange(49) if node.state[k] == 1)
\end{lstlisting}

\subsubsection{Other A* heuristics}

We tested various other heuristics before settling on our chosen two. One of
them was a baseline heuristic that simply returned the number of remaining
pegs. The other three were all variations on \(heuristicTwo\) with a different
\(difficulties\) array.

\begin{enumerate}

\item Manhattan distance from center:

\lstset{language=Python,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{keywordcolor}\ttfamily,
	identifierstyle=\color{idcolor}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{commentcolor}\ttfamily,
	numberstyle=\color{keywordcolor}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}[frame=single]
distances = [
	5, 4, 3, 2, 3, 4, 5,
	4, 3, 2, 1, 2, 3, 4,
	3, 2, 1, 0, 1, 2, 3,
	2, 1, 0, 1, 0, 1, 2,
	3, 2, 1, 0, 1, 2, 3,
	4, 3, 2, 1, 2, 3, 4,
	5, 4, 3, 2, 3, 4, 5
]
\end{lstlisting}

\item Alternative difficulties #1:

\lstset{language=Python,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{keywordcolor}\ttfamily,
	identifierstyle=\color{idcolor}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{commentcolor}\ttfamily,
	numberstyle=\color{keywordcolor}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}[frame=single]
distances = [
	0, 0, 4, 0, 4, 0, 0,
	0, 0, 0, 0, 0, 0, 0,
	4, 0, 3, 0, 3, 0, 4,
	0, 0, 0, 1, 0, 0, 0,
	4, 0, 3, 0, 3, 0, 4,
	0, 0, 0, 0, 0, 0, 0,
	0, 0, 4, 0, 4, 0, 0
]
\end{lstlisting}

\item Alternative difficulties #2:

\lstset{language=Python,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{keywordcolor}\ttfamily,
	identifierstyle=\color{idcolor}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{commentcolor}\ttfamily,
	numberstyle=\color{keywordcolor}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}
\begin{lstlisting}[frame=single]
distances = [
	0, 0, 1, 1, 1, 0, 0,
	0, 0, 1, 1, 1, 0, 0,
	1, 1, 0, 0, 0, 1, 1,
	1, 1, 0, 0, 0, 1, 1,
	1, 1, 0, 0, 0, 1, 1,
	0, 0, 1, 1, 1, 0, 0,
	0, 0, 1, 1, 1, 0, 0
]
\end{lstlisting}

\end{enumerate}

\section{Benchmarks}

\subsection{Test cases}

We wrote ten test cases manually based on actual game boards that people play,
such as a 9-peg plus shape, a 16-peg pyramid, a 24-peg diamond, or the 32-peg
"central game" with only one hole in the center.

We also implemented a generator for random valid test cases. It works by
starting with the goal state (only one peg in the center) and randomly picking
valid backward moves that could have reached that state. In pseudocode:

\begin{algorithm}
\caption{Random test case generator}
\label{random_alg}
\begin{algorithmic}[1]
	\State{$num\_step \gets$  a random number between 1 and 33 }
	\State{$board\_state \gets$ initialized board state with only one peg in the center }
	\For{$j \gets 1$ to $num\_step$}
		\State{$valid\_startpos, valid\_direction \gets$ find a valid random move}
		\State{$board\_state[valid\_startpos] \gets$ 0}
		\State{$board\_state[valid\_startpos + valid\_direction] \gets$ 1}
		\State{$board\_state[valid\_startpos + valid\_direction + valid\_direction] \gets$ 1}
	\EndFor
	\State \Return{$board\_state$}
\end{algorithmic}
\end{algorithm}

\subsection{Basic Cases}
And the result for our different methods are as shown in table \ref{tab_resbasic}:
\begin{table}[h!]
  \centering
  \begin{tabular}{ | c | c |  c | c | c | c |  c | c| c|}
\hline
case/num nodeExpand & ID-DFS & $A*- 1$ & $A*-2$ & $A*-3$ & $A*-4$ & $A*-Manhattan$ & $A*-mix$ & Baseline \\ \hline
given case & 50 & 16 & 14 & 18 & 22 & 19 & 13 & 13 \\ \hline
  \end{tabular}
  \caption{This table shows some data}
  \label{tab_resbasic}
\end{table}

\subsection{Impossible Case}
We added one case with two noncontiguous pegs. There shouldn't be solutions for such a case and the program should quit without hanging. In our test, only ID-DFS expanded two nodes and other methods expanded only one, and then the program quilted properly without any issue.

\subsection{Extreme Cases}
The most extreme case for this problem is the "all full but the center" condition that showed as the figure \ref{fig_full}. \\
\begin{figure} [h!]
\centering
\includegraphics[height=2.5in, width=3.5in]{figs/PegSolitaire_full.jpg}
\caption{Full but the center case}
\label{fig_full}
\end{figure}
And the result for our different methods are as shown in table \ref{tab_resfull}:
\begin{table}[h!]
  \centering
  \begin{tabular}{ | c | c |  c | c | c | c |  c | c| c|}
\hline
case/\#nodeExpand & ID-DFS & $A*- 1$ & $A*-2$ & $A*-3$ & $A*-4$ & $A*-Manhattan$ & $A*-mix$ & Baseline \\ \hline
Extreme & MemErr & 1,967,299 & 175 & 5,714,286 & 530,537 & 1,801,655 & 103,402 & 26,847 \\ \hline
  \end{tabular}
  \caption{This table shows some data}
  \label{tab_resfull}
\end{table}
\subsection{Mean and Median}
For the whole benchmark, we calculated the mean and the median numbers of the expanded nodes in table \ref{tbl_mean}. In comparison we chose $A*-1$ and $A*-mix24"$ in our final submitted program. \\
\begin{table}[h!]
  \centering
  \begin{tabular}{ | c | c |  c | c | c | c |  c | c| c|}
\hline
\#nodeExpand & ID-DFS & $A*- 1$ & $A*-2$ & $A*-3$ & $A*-4$ & $A*-Manhattan$ & $A*-mix$ & Baseline \\ \hline
Mean & 1,979,736, & 47,084 & 4,398 & 46,408 & 8,937 & 19,201 & 3,388 & 5,146 \\ \hline
Median & 6,417 & 74 & 129 & 74 & 114 & 95 & 98 & 92 \\ \hline
  \end{tabular}
  \caption{This table shows some data}
  \label{tbl_mean}
\end{table}

\subsection{Performance Study with other tricks}
In our testing, we found one interesting phenomenon. For several large cases, if the movement orders are different, for example, expand one node by the order "East, West, North, South" might be quite different from the order "East, North, West, South". \\
There are 24 possible orders, where $24 = 4!$, and we tested all the 24 possible orders with the above 6 methods, which included five A* methods and one baseline method. And we counted two sets of summations, one is the set of summations for "opposite-order first" for the movements and another set of summations is for the "non-opposite-order first". Here "opposite-order first" contained 12 conditions starting with opposite directions at the first two and the last two pairs such as "East, West, North, South". For "non-opposite-order first", such as "East, North, West, South". In a box plot in figure \ref{fig_boxplot}, it's obvious that the "non-opposite-order first" had better.
\begin{figure} [h!]
\centering
\includegraphics[height=3.5in, width=4.5in]{figs/boxplot.png}
\caption{Box plot for two sets of summations}
\label{fig_boxplot}
\end{figure}

\section{Conclusion}

TODO: conclusion

\end{document}
